import{z as v,A as u,b8 as f,b9 as x,Q as c,ba as g,bb as D,bc as M,bd as I,be as C,aS as m,bf as h,e as l}from"./index-DEk_hmx_.js";import{concatHex as V}from"./concat-hex-GR7tfDzJ.js";import{p as w}from"./index-C_TiQPHy.js";import"./send-eip712-transaction-s8UtqGnV.js";import"./eth_sendRawTransaction-DPdnXbFR.js";import"./sha256-Y7UsXzYY.js";const P="0x1626ba7e",_=[{name:"hash",type:"bytes32"},{name:"signature",type:"bytes"}],H=[{type:"bytes4"}];async function $(t){return v({contract:t.contract,method:[P,_,H],params:[t.hash,t.signature]})}const F="0x6492649264926492649264926492649264926492649264926492649264926492";function A({address:t,data:n,signature:e}){return V([u([{type:"address"},{type:"bytes"},{type:"bytes"}],[t,n,e]),F])}const O="0x1626ba7e";async function b({hash:t,signature:n,contract:e}){try{return await $({contract:e,hash:t,signature:n})===O}catch(r){return console.error("Error verifying EIP-1271 signature",r),!1}}const U=`Ethereum Signed Message:
`;function L(t,n){const e=typeof t=="string"?f(t):t.raw instanceof Uint8Array?t.raw:x(t.raw),r=f(`${U}${e.length}`);return c(g(r,e),n)}function B(t){const{domain:n={},message:e,primaryType:r}=t,a={EIP712Domain:D(n),...t.types};M({domain:n,message:e,primaryType:r,types:a});const s=["0x1901"];if(n&&s.push(I({domain:n,types:a})),r!=="EIP712Domain"){const i=(()=>{const o=S({data:e,primaryType:r,types:a});return c(o)})();s.push(i)}return c(g(...s.map(i=>C(i))))}function S({data:t,primaryType:n,types:e}){const r=[{type:"bytes32"}],a=[N({primaryType:n,types:e})];if(!e[n])throw new Error("Invalid types");for(const s of e[n]){const[i,o]=E({name:s.name,type:s.type,types:e,value:t[s.name]});r.push(i),a.push(o)}return u(r,a)}function N({primaryType:t,types:n}){const e=m(k({primaryType:t,types:n}));return c(e)}function k({primaryType:t,types:n}){let e="";const r=T({primaryType:t,types:n});r.delete(t);const a=[t,...Array.from(r).sort()];for(const s of a){if(!n[s])throw new Error("Invalid types");e+=`${s}(${n[s].map(({name:i,type:o})=>`${o} ${i}`).join(",")})`}return e}function T({primaryType:t,types:n},e=new Set){const a=t.match(/^\w*/u)?.[0];if(e.has(a)||n[a]===void 0)return e;e.add(a);for(const s of n[a])T({primaryType:s.type,types:n},e);return e}function E({types:t,name:n,type:e,value:r}){if(t[e]!==void 0)return[{type:"bytes32"},c(S({data:r,primaryType:e,types:t}))];if(e==="bytes")return r=`0x${(r.length%2?"0":"")+r.slice(2)}`,[{type:"bytes32"},c(r)];if(e==="string")return[{type:"bytes32"},c(m(r))];if(e.lastIndexOf("]")===e.length-1){const a=e.slice(0,e.lastIndexOf("[")),s=r.map(i=>E({name:n,type:a,types:t,value:i}));return[{type:"bytes32"},c(u(s.map(([i])=>i),s.map(([,i])=>i)))]}return[{type:e},r]}async function K({accountContract:t,factoryContract:n,options:e,message:r}){const a=L(r);let s;const i=u([{type:"bytes32"}],[a]);if(s=await e.personalAccount.signTypedData({domain:{chainId:e.chain.id,name:"Account",verifyingContract:t.address,version:"1"},message:{message:i},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]}}),await h(t)){if(await b({contract:t,hash:a,signature:s}))return s;throw new Error("Failed to verify signature")}else{const y=w({accountSalt:e.overrides?.accountSalt,adminAddress:e.personalAccount.address,createAccountOverride:e.overrides?.createAccount,factoryContract:n});if(!y)throw new Error("Create account override not provided");const d=await l(y);return A({address:n.address,data:d,signature:s})}}async function W({accountContract:t,factoryContract:n,options:e,typedData:r}){if(r.domain?.verifyingContract?.toLowerCase()===t.address?.toLowerCase())return e.personalAccount.signTypedData(r);const s=B(r);let i;const o=u([{type:"bytes32"}],[s]);if(i=await e.personalAccount.signTypedData({domain:{chainId:e.chain.id,name:"Account",verifyingContract:t.address,version:"1"},message:{message:o},primaryType:"AccountMessage",types:{AccountMessage:[{name:"message",type:"bytes"}]}}),await h(t)){if(await b({contract:t,hash:s,signature:i}))return i;throw new Error("Failed to verify signature")}else{const d=w({accountSalt:e.overrides?.accountSalt,adminAddress:e.personalAccount.address,createAccountOverride:e.overrides?.createAccount,factoryContract:n});if(!d)throw new Error("Create account override not provided");const p=await l(d);return A({address:n.address,data:p,signature:i})}}export{K as smartAccountSignMessage,W as smartAccountSignTypedData};
